# Unicode multi-stage table builder
# (c) Peter Kankowski, 2008
# Released under the zlib/libpng license (http://www.opensource.org/licenses/zlib-license.php)
# Adapted for Boost.Spirit, Joel de Guzman

# Build the table, including compacting the identical blocks
# and choosing the smallest possible item size
class TableBuilder:
    def __init__(self, block_size):
        self.blocks = {} # Dictionary for finding identical blocks
        self.stage1 = [] # Stage 1 table contains block numbers (indices into stage 2 table)
        self.stage2 = [] # Stage 2 table contains the blocks with property values
        self.block_size = block_size

    def add_block(self, block, count = 1):
        assert(len(block) == self.block_size)

        # If there is such block in the stage2 table, use it
        tblock = tuple(block)
        start = self.blocks.get(tblock)
        if start is None:
            # Allocate a new block
            start = len(self.stage2) / self.block_size
            self.stage2 += block
            self.blocks[tblock] = start

        # Add 'count' blocks with the same values
        self.stage1 += [start] * count

    def __get_type_size(self, seq):
        type_size = [("::boost::uint8_t", 1), ("::boost::uint16_t", 2), ("::boost::uint32_t", 4),
                     ("::boost::int8_t", 1), ("::boost::int16_t", 2), ("::boost::int32_t", 4)]
        limits = [(0, 255), (0, 65535), (0, 4294967295),
                  (-128, 127), (-32768, 32767), (-2147483648, 2147483647)]
        minval = min(seq)
        maxval = max(seq)
        for num, (minlimit, maxlimit) in enumerate(limits):
            if minlimit <= minval and maxval <= maxlimit:
                return type_size[num]
        else:
            raise OverflowError, "Too large to fit into C++ types"

    def print_table(self, prop_name):
        stage1_type, stage1_size = self.__get_type_size(self.stage1)
        stage2_type, stage2_size = self.__get_type_size(self.stage2)

        # Print header
        lic ='''/*=============================================================================
    Copyright (c) 2001-2009 Joel de Guzman

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Autogenerated by MultiStageTable.py (Unicode multi-stage
    table builder) (c) Peter Kankowski, 2008

    DO NOT EDIT!!!
==============================================================================*/'''

        total_size = len(self.stage1) * stage1_size + len(self.stage2) * stage2_size
        print lic
        print "// %s table, %d bytes" % (prop_name, total_size)
        print "\nnamespace boost { namespace spirit { namespace unicode { namespace detail \n{"

        # Print the first stage
        print "    static const %s %s_stage1[] = {" % (stage1_type, prop_name)
        for i, block in enumerate(self.stage1):
            if i % 16 == 0:
                print "   ",
            print ("%2d," % block),
            if i % 16 == 15:
                print "// U+%04X" % ((i - 15) * self.block_size)
        print "    };\n"

        # Print the second stage
        print "    static const %s %s_stage2[] = {" % (stage2_type, prop_name)
        for i, val in enumerate(self.stage2):
            if i % self.block_size == 0:
                print "\n    // block %d" % (i / self.block_size)
            if i % 16 == 0:
                print "   ",
            print ("%2d," % val),
            if i % 16 == 15:
                print ""
        print "    };\n"

        # Print access function
        func = """
}}}}

namespace boost { namespace spirit { namespace unicode
{
    %(p)s get_%(p)s(::boost::uint32_t ch)
    {
        const ::boost::uint32_t block_size = %(size)d;
        assert(ch < 0x110000);
        ::boost::uint32_t block_offset = detail::%(p)s_stage1[ch / block_size] * block_size;
        %(t)s r = detail::%(p)s_stage2[block_offset + ch %% block_size];
        return static_cast<%(p)s>(r);
    }
}}}

"""
        print func % {'t':stage2_type, 'p':prop_name, 'size':self.block_size}


# Read UnicodeData.txt file
class UnicodeDataExtractor:
    def __init__(self, block_size, add_block_func):
        self.block_size = block_size
        self.add_block_func = add_block_func
        self.block = []
        self.next_char = 0
        self.def_val = 18 # the default value is 'Cn' (General_Category=Unassigned)
        self.span_val = self.def_val

    def __decode(self, chardata):
        categories = {'Lu':0, 'Ll':1, 'Lt':2, 'Lm':3, 'Lo':4, \
                      'Mn':5, 'Me':6, 'Mc':7, \
                      'Nd':8, 'Nl':9, 'No':10, \
                      'Zs':11, 'Zl':12, 'Zp':13, \
                      'Cc':14, 'Cf':15, 'Co':16, 'Cs':17, 'Cn':18, \
                      'Pd':19, 'Ps':20, 'Pe':21, 'Pc':22, 'Po':23, 'Pi':24, 'Pf':25, \
                      'Sm':26, 'Sc':27, 'Sk':28, 'So':29}
        return categories[chardata[2]]

    def __add_char(self, val):
        # Add to the block while it's not filled
        self.block.append(val)
        if len(self.block) == self.block_size:
            self.add_block_func(self.block)
            self.block = []

    def __add_chars(self, val, count):
        n = min(self.block_size - len(self.block), count)
        for i in range(n):
            self.block.append(val)
        if len(self.block) == self.block_size:
            self.add_block_func(self.block)
            self.block = []

        # Add a lot of blocks in a long span (optimized)
        if (count - n) / self.block_size != 0:
            block = [val] * self.block_size
            self.add_block_func(block, (count - n) / self.block_size)

        # Add the remaining chars
        for i in range((count - n) % self.block_size):
            self.block.append(val)

    def add_line(self, line):
        chardata = line.split(';')
        char = int(chardata[0], 16)
        # Add unassigned characters or the preceding span
        if char > self.next_char:
            self.__add_chars(self.span_val, char - self.next_char)
        val = self.__decode(chardata)
        self.__add_char(val)

        # Special mode for character spans
        self.span_val = self.def_val if chardata[1][-8:] != ', First>' else val
        self.next_char = char + 1

    def finish(self):
        for i in range(self.next_char, 0x110000):
            self.__add_char(self.span_val)

# import time
# start = time.clock()

block_size = 256
builder = TableBuilder(block_size)
extractor = UnicodeDataExtractor(block_size, builder.add_block)
file = open('UnicodeData.txt', 'r')
for line in file:
    extractor.add_line(line)
extractor.finish()
builder.print_table('category')

# print "// %.2f sec" % (time.clock() - start)
