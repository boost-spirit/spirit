[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[/////////////////////////////////////////////////////////////////////////////]
[section:karma_complex Complex - A first more complex generator]

In this section we will develop a generator for complex numbers, allowing to 
represent a `std::complex` either as `"(real, imag)"` (where `real` and `imag` 
are the real and imaginary parts of the complex number) or as a simple `real`
if the imaginary part happens ot be equal to zero. This example will highlight
the power of __karma__ allowing to combine compile time definition of 
formatting rules with runtime based decisions which of the rules to apply. 
Also this time, we're using __boost_phoenix__ to do the semantic actions.

Our goal is to allow for two different output formats to be applied depending 
on whether the imaginary part of the complex number is zero or not. Let's write
both as a set of alternatives:

        '(' << double_ << ", " << double_ << ')'
    |   double_

where the first alternative should be used for numbers having a non-zero 
imaginary part, while the second is for real numbers. Generally, alternatives
are tried in the sequence of their definition as long as one of the
expressions (as delimited by `'|'`) succeeds. If no generator expression 
succeeds the whole alternative fails.

If we left this formatting grammar as it is our generator would always choose 
the first alternative. We need to add some additional rules allowing to make 
the first alternative to fail. So, if the first fails the second alternative will 
be chosen instead. The decision about whether to choose the first alternative 
has to be made at runtime as only then we actually know the value of the 
imaginary part of the complex number. __karma__ provides us with with a 
primitive generator `eps()`, which is usable as a semantic predicate. It has 
the property to 'succeed' generating only if its argument is true (while it 
never generates any output on its own).

    double imag = ...;     // imaginary part

        eps(imag != 0) << '(' << double_ << ", " << double_ << ')'
    |   double_

If one of the generator elements of a sequence fails the whole sequence will 
fail. This is exactly what we need, forcing the second alternative to be chosen 
for complex numbers with imaginary parts equal to zero.

[import ../../example/karma/complex_number.cpp]

Here goes the full example, this time with the proper semantic actions (The 
full cpp file for this example can be found here: 
[@../../example/karma/complex_number.cpp complex_number.cpp]).

This is the complex type we will use for this and all subsequent realted 
examples:

[tutorial_karma_complex_number_type]

And here you can see the full code of the generator allowing to output a 
complex number either as a pair of numbers (if the imaginary part is non-zero)
or as a single number (if the complex is a real number):

[tutorial_karma_complex_number]

The `double_` generators have this semantic action attached:

    _1 = n

Remember, semantic actions in __karma__ are called before the corresponding 
generator is invoked and they are expected to provide the generator with the 
data to be used. The semantic action above assigns the value to be generated 
(n) to the generator (actually, the attribute of `double_`) . `_1` is a Phoenix 
placeholder for the attribute of the generator the semantic action is attached 
to.

These semantic actions are easy to understand but have the unexpected side 
effect of being slightly less efficient than it could be. In addition they tend
to make the formatting grammar less readable. We will see in one of the next 
sections how it is possible to use built in features of __karma__ to get rid of 
the semantic actions alltogether.

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:karma_attributes Understanding Generator Attributes]

[heading Attributes of Primitive Generators]

Before we can start simplifying the complex number example from the previous
section we need to introduce the notion of generator attributes. Every generator 
component in __karma__ exposes a specific attribute type. We have already seen
that the attribute type of the `double_` generator is `double`. Other primitive
generator components have other intuitive attribute types, such as for instance
`int_` which has `int`, or `ascii::char_` which has `char`. For a full list of
available generator primitives and their attribute types please see the section
__sec_karma_primitive__.

The attribute type of a generator defines what data types this generator is 
able to consume in order to produce its output. For primitive generators the 
normal C++ convertibility rules apply. Any data type convertible to the 
attribute type of a primitive generator can be used to provide the data to 
generate. As an example, it is possible to use an integer value in conjunction
with a `double_` generator:

    // the following generates: 1.0
    std::string str;
    std::back_insert_iterator<std::string> out(str);
    generate(out, double_, 1);

[heading Attributes of Compound Generators]

__karma__ implements well defined attribute type propagation rules for all 
compound generators, such as sequences, alternatives, Kleene star, etc. The 
main attribute propagation rule for a sequences is for instance:

    a: A, b: B --> (a << b): tuple<A, B>

which reads as:

[:Given `a` and `b` are generators, and `A` is the attribute type of `a`, and
  `B` is the attribute type of `b`, then the attribute type of `a << b` will be
  `tuple<A, B>`.]

[note The notation `tuple<A, B>` is used as a placeholder expression for any 
      fusion sequence holding the types A and B, such as 
      `boost::fusion::tuple<A, B>` or `std::pair<A, B>` (for more information 
      see __fusion__).]

As you can see, in order for a type to be compatible with the attribute type 
of a __karma__ compound generator it has to 

* either be convertible to the attribute type, 
* or it has to expose certain functionalities, i.e. it needs to conform to a 
  concept compatible with the generator.

Each compound generator implements its own set of attribute propagation rules.
For a full list of how the different compound generators consume attributes
see the section __sec_karma_compound__.

[heading The Attribute of Sequence Generators]

Sequences require an attribute type to expose the concept of a fusion sequence,
where all elements of that fusion sequence have to be compatible with the 
corresponding element of the __karma__ generator sequence. For example, the
expression:

    double_ << double_

is able to consume any fusion sequence holding two types, where both types have
to be convertible to `double`. The first element of the fusion sequence has to 
be compatible with the attribute of the first `double_` (i.e. it needs to be
convertible to a `double`), and the second element of the fusion sequence has 
to be compatible with the attribute of the second `double_` (i.e. convertible 
to a `double` as well). If we assume to have an instance of a 
`std::pair<double, double>`, we can directly use the expression above:

    // the following generates: 1.0 2.0
    std::string str;
    std::back_insert_iterator<std::string> out(str);
    generate(out, 
        double_ << double_,             // generator grammar (format description)
        space,                          // delimiter grammar
        std::make_pair(1.0, 2.0));      // data to use as the attribute 

(where the `space` generator is used as the delimiter, allowing to 
automatically insert delimiting spaces in between all primitives). 

[tip  *For sequences only:* __karma__ exposes a set of API functions usable 
      mainly with sequences. Very much like the functions of the `printf` 
      family these functions allow to pass the attributes for each of the 
      elements of the sequence separately. Using the corresponding overload of 
      /Karma's/ `generate()` the expression above could be rewritten as:

      ``generate(out, double_ << double_, space, 1.0, 2.0);``

      where the first attribute (`1.0`) is used for the first `double_`, and 
      the second attribute (`2.0`) is used for the second `double_`.
]

[heading More About Attributes of Compound Generators]

While generating output it is often desirable to combine some constant 
elements with variable parts. For instance, if we go back to our example of
formatting a complex number, we need to write it as `(re, im)`, where `re` and
`im` are the variables representing the real and imaginary parts of our
complex number. As we have already seen, this can be achieved by writing

    '(' << double_ << ", " << double_ << ')'

Fortunately, literals (such as `'('` and `", "`) do not expose any attribute
(well actually, they do expose the special type `unused_type`, but in this 
context `unused_type` is interpreted as if the generator does not expose any 
attribute at all). It is very important to understand that the literals don't 
consume any of the elements of a fusion sequence passed to this generator 
sequence. The following example shows this:

    // the following generates: (1.0, 2.0)
    std::string str;
    std::back_insert_iterator<std::string> out(str);
    generate(out, 
        '(' << double_ << ", " << double_ << ')',  // generator grammar (format description)
        std::make_pair(1.0, 2.0));                 // data to use as the attribute 

This behavior should be familiar as it conforms to the way other output 
formatting libraries such as `printf` or `boost::format` are handling their
variable parts. In this context you can think about __karma__'s primitive
generators (such as the `double_` above) as of being placeholders for the 
attribute values to print.

[heading Attributes of Rules and Grammars]

* explicit attribute type
* attribute propagation
  * explicit and operator%=

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:karma_easier_complex Complex - Made easier]

In one of the previous sections we showed how to format a complex number (i.e. 
a pair of doubles). In this section we will build on this example with the goal 
to avoid to use semantic actions in the format specification. Let's have a look 
at the resulting code first, trying to understand it afterwards.

[endsect]

