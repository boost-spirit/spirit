[/==============================================================================
    Copyright (C) 2001-2009 Hartmut Kaiser
    Copyright (C) 2001-2009 Joel de Guzman

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:numeric Numeric]

This module includes different numeric generators allowing to format arbitrary 
integer and real number types. It includes the signed integer, unsigned 
integer, and real number generators.

[heading Module Header]

    // forwards to <boost/spirit/home/karma/numeric.hpp>
    #include <boost/spirit/include/karma_numeric.hpp>

Also, see __include_structure__.

[/////////////////////////////////////////////////////////////////////////////]
[section:signed_int Signed Integer Number Generators]

[heading Description]

The signed integer number generators described in this section are:

[table
    [[Expression]          [Attribute]     [Description]]
    [[`lit(num)`]          [`Unused`]      [Generates `num`, where `num` can be a `short`,
                                            `int`, `long`, or `long long`, same as 
                                            `boost::spirit::lit`]]
    [[`short_`]            [`short`]       [Generate a `short int` as given by the
                                            mandatory attribute]]
    [[`short_(num)`]       [`short`]       [Generate `num` as a `short int`, 
                                            if an attribute is supplied it must match]]
    [[`int_`]              [`int`]         [Generate an `int` as given by the
                                            mandatory attribute]]
    [[`int_(num)`]         [`int`]         [Generate `num` as an `int`, 
                                            if an attribute is supplied it must match]]
    [[`long_`]             [`long`]        [Generate a `long int` as given by the
                                            mandatory attribute]]
    [[`long_(num)`]        [`long`]        [Generate `num` as `long int`, 
                                            if an attribute is supplied it must match]]
    [[`long_long`]         [`long long`]   [Generate a `long long` as given by the
                                            mandatory attribute]]
    [[`long_long(num)`]    [`long long`]   [Generate `num` as an `long long`, 
                                            if an attribute is supplied it must match]]
    [
[``int_generator<
    Num, Radix, force_sign
>()``]
                           [`Num`]                [Generate a `Num`]]
    [
[``int_generator<
    Num, Radix, force_sign
>()(num)``]
                           [`Num`]                [Generate `num` as a `Num`, 
                                                   if an attribute is supplied it must match]]
]

These can be used to flexibly format any integer number of any compatible type
(for more information about the requirements, see 
[link spirit.karma.reference.numeric.signed_int.additional_requirements below]).

[note   The generators `long_long` and `long_long(num)` are only available on 
        platforms where the preprocessor constant `BOOST_HAS_LONG_LONG` is 
        defined (i.e. on platforms having native support for `long long` 
        (64 bit) integer types).]

The integer number generators are very fast. For measurement results comparing
the __karma__ integer number generators with equivalent constructs provided by 
other libraries see the section 
[link spirit.karma.performance_measurements.numeric_performance.int_performance Performance of Numeric Generators]

[heading Header]

    // forwards to <boost/spirit/home/karma/numeric/int.hpp>
    #include <boost/spirit/include/karma_int.hpp>

Also, see __include_structure__.

[heading Model of]

[:__primitive_generator_concept__]

[variablelist Notation
    [[`num`]            [Numeric literal, any signed integer value, or
                         a __karma_lazy_argument__ that evaluates to a signed 
                         integer value of type `Num`]]
    [[`Num`]            [Type of `num`: any signed integer type]]
    [[`Radix`]          [A constant integer literal specifying the required 
                         radix for the output conversion. Valid values are `2`, 
                         `8`, `10`, and `16`.]]
    [[`force_sign`]     [A constant boolean literal specifying whether the
                         generated number should always have a sign (`'+'` for
                         positive numbers, `'-'` for negative numbers and a 
                         '` `' for zero).]]
    ]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is
not defined in __primitive_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`lit(num)`]       [Generate the integer literal `num` using the default
                         formatting (radix is 10, sign is only printed for 
                         negative literals). This generator never fails (except 
                         if the underlying output stream reports an error).]]
    [
[``short_
int_
long_
long_long``]            [Generate the integer provided by a mandatory attribute
                         using the default formatting (radix is 10, sign is 
                         only printed for negative literals). This generator 
                         never fails (except if the underlying output stream 
                         reports an error).]]
    [
[``short_(num)
int_(num)
long_(num)
long_long(num)``]       [Generate the integer provided by the immediate literal
                         value the generator is initialized from using the 
                         default formatting (radix is 10, sign is only printed 
                         for negative literals). If this generator has an 
                         associated attribute it succeeds only as long as the 
                         attribute is equal to the immediate literal (except if 
                         the underlying output stream reports an error). 
                         Otherwise this generator fails and does not generate 
                         any output.]]
]

All generators listed in the table above (except `lit(num)`) are predefined 
specializations of the `int_generator<Num, Radix, force_sign>` basic integer
number generator type described below. It is possible to directly use this
type to create integer generators using a wide range of formatting options.

[table
    [[Expression]       [Semantics]]
    [
[``int_generator<
    Num, Radix, force_sign
>()``]
                        [Generate the integer of type `Num` provided by a 
                         mandatory attribute using the specified `Radix` 
                         (possible values are `2`, `8`, `10`, and `16`, the 
                         default value is `10`). If `force_sign` is `false` 
                         (the default), a sign is only printed for negative 
                         literals. If `force_sign` is `true`, all numbers will 
                         be printed using a sign, i.e. `'-'` for negative 
                         numbers, `'+'` for positive numbers, and `' '` for 
                         zeros. This generator never fails (except if the 
                         underlying output stream reports an error).]]
    [
[``int_generator<
    Num, Radix, force_sign
>()(num)``]
                        [Generate the integer of type `Num` provided by the 
                         immediate literal value the generator is initialized 
                         from, using the specified `Radix` (possible values are
                         `2`, `8`, `10`, and `16`, the default value is `10`). 
                         If `force_sign` is `false` (the default), a sign is 
                         only printed for negative literals. If `force_sign` is 
                         `true`, all numbers will be printed using a sign, i.e.
                         `'-'` for negative numbers, `'+'` for positive numbers,
                         and `' '` for zeros. If this generator has an 
                         associated attribute it succeeds only as long as the 
                         attribute is equal to the immediate literal (except if 
                         the underlying output stream reports an error). 
                         Otherwise this generator fails and does not generate 
                         any output.]]
]

[heading Template parameters]

[table
    [[Parameter]        [Description]               [Default]]
    [[`Num`]            [The type of the integer 
                         to generate]               [`int`]]
    [[`Radix`]          [The radix to use while 
                         converting the integer]    [`10`]]
    [[`force_sign`]     [If `true`, all numbers will
                         have a sign (space for 
                         zero)]                     [`false`]]
]

[heading Additional Requirements]

The following lists enumerate the requirements which must be met in order to 
use a certain type `Num` to instantiate and use a 
`int_generator<Num, Radix, force_sign>`.

If `boost::is_integral<Num>::value` is `true` the type `Num` must have defined:

* comparison operators for: `<`, `<=`, `==`, `!=`, `>`, and `>=` 
* numeric operators for: `+`, `-`, `/`, `*`, `%`, and unary `-`

If `boost::is_integral<Num>::value` is `false` the type `Num` must have defined:

* comparison operators for: `<`, `<=`, `==`, `!=`, `>`, and `>=` 
* numeric operators for: `+`, `-`, `/`, `*`, `%`, and unary `-`
* helper functions implementing the interface and the semantics of: `std::fmod`, 
  `std::fabs`, `std::pow`, `std::lround`, `std::ltrunc`, `std::floor`, and
  `std::ceil`. These need to be defined in a way so that they will be found 
  using argument dependent lookup (ADL).

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[`lit(num)`]       [__unused__]]
    [[`short_`]         [`short`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`short_(num)`]    [`short`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [[`int_`]           [`int`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`int_(num)`]      [`int`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [[`long_`]          [`long`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`long_(num)`]     [`long`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [[`long_long`]      [`long long`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`long_long(num)`] [`long long`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [
[``int_generator<
    Num, Radix, force_sign
>()``]                  [`Num`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [
[``int_generator<
    Num, Radix, force_sign
>()(num)``]             [`Num`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]
]

[heading Complexity]

[:O(N), where `N` is the number of digits needed to represent the generated 
 integer number]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use these common test functions:

[reference_karma_test]
[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_int]

Basic usage of an `int_` generator:

[reference_karma_int]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:unsigned_int Unsigned Integer Number Generators]

[heading Description]
The signed integer number generators described in this section are:

[table
    [[Expression]          [Attribute]            [Description]]
    [[`lit(num)`]          [__unused__]           [Generates `num`, where `num` can be a `unsigned short`,
                                                   `unsigned int`, `unsigned long`, or `unsigned long long`, 
                                                   same as `boost::spirit::lit`]]
    [[`ushort`]            [`unsigned short`]     [Generate a short integer]]
    [[`ushort(num)`]       [`unsigned short`]     [Generate `num` as a short integer, 
                                                   if an attribute is supplied it must match]]
    [[`uint`]              [`unsigned int`]       [Generate an int]]
    [[`uint(num)`]         [`unsigned int`]       [Generate `num` as an int, 
                                                   if an attribute is supplied it must match]]
    [[`ulong`]             [`unsigned long`]      [Generate a long integer]]
    [[`ulong(num)`]        [`unsigned long`]      [Generate `num` as long integer, 
                                                   if an attribute is supplied it must match]]
    [[`ulong_long`]        [`unsigned long long`] [Generate a long long]]
    [[`ulong_long(num)`]   [`unsigned long long`] [Generate `num` as an long long, 
                                                   if an attribute is supplied it must match]]
    [
[``uint_generator<
    Num, Radix
>()``]
                           [`Num`]                [Generate an unsigned `Num`]]
    [
[``uint_generator<
    Num, Radix
>()(num)``]
                           [`Num`]                [Generate an unsigned `num` as a `Num`, 
                                                   if an attribute is supplied it must match]]
    [[`bin`]               [`unsigned int`]       [Generate an unsigned integer in binary 
                                                   (base 2) representation]]
    [[`bin(num)`]          [`unsigned int`]       [Generate `num` as an unsigned integer in
                                                   binary (base 2) representation, if an attribute is 
                                                   supplied it must match]]
    [[`oct`]               [`unsigned int`]       [Generate an unsigned integer in octal (base 8) 
                                                   representation]]
    [[`oct(num)`]          [`unsigned int`]       [Generate `num` as an unsigned integer in
                                                   octal (base 8) representation, if an attribute is 
                                                   supplied it must match]]
    [[`hex`]               [`unsigned int`]       [Generate an unsigned integer in hexadecimal 
                                                   (base 16) representation]]
    [[`hex(num)`]          [`unsigned int`]       [Generate `num` as an unsigned integer in
                                                   hexadecimal (base 16) representation, if an 
                                                   attribute is supplied it must match]]
]

These can be used to flexibly format any unsigned integer number of any 
compatible type (for more information about the requirements, see 
[link spirit.karma.reference.numeric.unsigned_int.additional_requirements below]).

[note   The generators `ulong_long` and `ulong_long(num)` are only available on 
        platforms where the preprocessor constant `BOOST_HAS_LONG_LONG` is 
        defined (i.e. on platforms having native support for `unsigned long long` 
        (64 bit) unsigned integer types).]

The integer number generators are very fast. For measurement results comparing
the __karma__ integer number generators with equivalent constructs provided by 
other libraries see the section 
[link spirit.karma.performance_measurements.numeric_performance.int_performance Performance of Numeric Generators]

[heading Header]

    // forwards to <boost/spirit/home/karma/numeric/uint.hpp>
    #include <boost/spirit/include/karma_uint.hpp>

Also, see __include_structure__.

[heading Model of]

[:__primitive_generator_concept__]

[variablelist Notation
    [[`num`]            [Numeric literal, any unsigned integer value, or
                         a __karma_lazy_argument__ that evaluates to an 
                         unsigned integer value of type `Num`]]
    [[`Num`]            [Type of `num`: any unsigned integer type]]
    [[`Radix`]          [A integer literal specifying the required radix for 
                         the output conversion. Valid values are `2`, `8`, `10`,
                         and `16`.]]]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is
not defined in __primitive_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`lit(num)`]       [Generate the integer literal `num` using the default
                         formatting (radix is 10, sign is only printed for 
                         negative literals). This generator never fails (except 
                         if the underlying output stream reports an error).]]
    [
[``ushort
uint
ulong
ulong_long``]           [Generate the unsigned integer provided by a mandatory 
                         attribute using the default formatting (radix is 10). 
                         This generator never fails (except if the underlying 
                         output stream reports an error).]]
    [
[``ushort(num)
uint(num)
ulong(num)
ulong_long(num)``]      [Generate the unsigned integer provided by the 
                         immediate literal value the generator is initialized 
                         from using the default formatting (radix is 10). If 
                         this generator has an associated attribute it succeeds 
                         only as long as the attribute is equal to the 
                         immediate literal (except if the underlying output 
                         stream reports an error). Otherwise this generator 
                         fails and does not generate any output.]]
    [
[``bin
oct
hex``]                  [Generate the unsigned integer provided by a mandatory 
                         attribute using the default formatting and the 
                         corresponding radix (`bin`: radix is 2, `oct`: radix is 8,
                         `hex`: radix is 16). This generator never fails (except 
                         if the underlying output stream reports an error).]]
    [
[``bin(num)
oct(num)
hex(num)``]             [Generate the unsigned integer provided by the 
                         immediate literal value the generator is initialized 
                         from using the default formatting and the 
                         corresponding radix (`bin`: radix is 2, `oct`: 
                         radix is 8, `hex`: radix is 16). If 
                         this generator has an associated attribute it succeeds 
                         only as long as the attribute is equal to the 
                         immediate literal (except if the underlying output 
                         stream reports an error). Otherwise this generator 
                         fails and does not generate any output.]]
]

All generators listed in the table above (except `lit(num)`) are predefined 
specializations of the `uint_generator<Num, Radix>` basic unsigned integer
number generator type described below. It is possible to directly use this
type to create unsigned integer generators using a wide range of formatting
options.

[table
    [[Expression]       [Semantics]]
    [
[``uint_generator<
    Num, Radix
>()``]
                        [Generate the unsigned integer of type `Num` provided 
                         by a mandatory attribute using the specified `Radix` 
                         (possible values are `2`, `8`, `10`, and `16`, the 
                         default value is `10`).This generator never fails 
                         (except if the underlying output stream reports an 
                         error).]]
    [
[``uint_generator<
    Num, Radix
>()(num)``]
                        [Generate the unsigned integer of type `Num` provided 
                         by the immediate literal value the generator is 
                         initialized from, using the specified `Radix` 
                         (possible values are `2`, `8`, `10`, and `16`, the 
                         default value is `10`). If this generator has an 
                         associated attribute it succeeds only as long as the 
                         attribute is equal to the immediate literal (except if 
                         the underlying output stream reports an error). 
                         Otherwise this generator fails and does not generate 
                         any output.]]
]

[heading Template parameters]

[table
    [[Parameter]        [Description]               [Default]]
    [[`Num`]            [The type of the integer 
                         to generate]               [`unsigned int`]]
    [[`Radix`]          [The radix to use while 
                         converting the integer]    [`10`]]
]

[heading Additional Requirements]

The following lists enumerate the requirements which must be met in order to 
use a certain type `Num` to instantiate and use a 
`uint_generator<Num, Radix>`.

If `boost::is_integral<Num>::value` is `true` the type `Num` must have defined:

* comparison operators for: `<`, `<=`, `==`, `!=`, `>`, and `>=` 
* numeric operators for: `+`, `-`, `/`, `*`, and `%`

If `boost::is_integral<Num>::value` is `false` the type `Num` must have defined:

* comparison operators for: `<`, `<=`, `==`, `!=`, `>`, and `>=` 
* numeric operators for: `+`, `-`, `/`, `*`, and `%`
* helper functions implementing the interface and the semantics of: `std::fmod`, 
  `std::pow`, `std::lround`, `std::ltrunc`, `std::floor`, and `std::ceil`. 
  These need to be defined in a way so that they will be found using argument 
  dependent lookup (ADL).

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[`lit(num)`]       [__unused__]]
    [[`ushort`]         [`unsigned short`, attribute is mandatory (otherwise 
                         compilation will fail)]]
    [[`ushort(num)`]    [`unsigned short`, attribute is optional, if it is 
                         supplied, the generator compares the attribute with 
                         `num` and succeeds only if both are equal, failing 
                         otherwise.]]

    [[`uint`]           [`unsigned int`, attribute is mandatory (otherwise 
                         compilation will fail)]]
    [[`uint(num)`]      [`unsigned int`, attribute is optional, if it is 
                         supplied, the generator compares the attribute with 
                         `num` and succeeds only if both are equal, failing 
                         otherwise.]]

    [[`ulong`]          [`unsigned long`, attribute is mandatory (otherwise 
                         compilation will fail)]]
    [[`ulong(num)`]     [`unsigned long`, attribute is optional, if it is 
                         supplied, the generator compares the attribute with 
                         `num` and succeeds only if both are equal, failing 
                         otherwise.]]

    [[`ulong_long`]     [`unsigned long long`, attribute is mandatory 
                         (otherwise compilation will fail)]]
    [[`ulong_long(num)`][`unsigned long long`, attribute is optional, if it is 
                         supplied, the generator compares the attribute with 
                         `num` and succeeds only if both are equal, failing 
                         otherwise.]]

    [
[``bin
oct
hex``]                  [`unsigned int`, attribute is mandatory 
                         (otherwise compilation will fail)]]
    [
[``bin(num)
oct(num)
hex(num)``]             [`unsigned int`, attribute is optional, if it is 
                         supplied, the generator compares the attribute with 
                         `num` and succeeds only if both are equal, failing 
                         otherwise.]]

    [
[``uint_generator<
    Num, Radix
>()``]                  [`Num`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [
[``uint_generator<
    Num, Radix
>()(num)``]             [`Num`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]
]

[heading Complexity]

[:O(N), where `N` is the number of digits needed to represent the generated 
 integer number]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use these common test functions:

[reference_karma_test]
[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_uint]

Basic usage of an `uint` generator:

[reference_karma_uint]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:real_number Real Number Generators]

[heading Description]

The real number generators described in this section are:

[table
    [[Expression]          [Attribute]     [Description]]
    [[`lit(num)`]          [`Unused`]      [Generates `num`, where `num` can be a `float`,
                                            `double`, or `long double`, same as 
                                            `boost::spirit::lit`]]
    [[`float_`]            [`float`]       [Generate a `float` as given by the
                                            mandatory attribute]]
    [[`float_(num)`]       [`float`]       [Generate `num` as a `float`, 
                                            if an attribute is supplied it must match]]
    [[`double_`]           [`double`]      [Generate a `double` as given by the
                                            mandatory attribute]]
    [[`double_(num)`]      [`double`]      [Generate `num` as a `double`, 
                                            if an attribute is supplied it must match]]
    [[`long_double`]       [`long double`] [Generate a `double` as given by the
                                            mandatory attribute]]
    [[`long_double(num)`]  [`long double`] [Generate `num` as a `double`, 
                                            if an attribute is supplied it must match]]
    [
[``real_generator<
    Num, Policies
>()``]
                           [`Num`]         [Generate a `Num` using the provided 
                                            policies `Policies`]]
    [
[``real_generator<
    Num, Policies
>()(num)``]
                           [`Num`]         [Generate `num` as a `Num` using the provided 
                                            policies `Policies`, if an attribute is 
                                            supplied it must match]]
]

These can be used to flexibly format any real number of any 
compatible type (for more information about the requirements, see 
[link spirit.karma.reference.numeric.real_number.additional_requirements below]).

The real number generators are very fast. For measurement results 
comparing the __karma__ real number generators with equivalent 
constructs provided by other libraries see the section 
[link spirit.karma.performance_measurements.numeric_performance.double_performance Performance of Floating Point Numeric Generators]

[heading Header]

    // forwards to <boost/spirit/home/karma/numeric/real.hpp>
    #include <boost/spirit/include/karma_real.hpp>

Also, see __include_structure__.

[heading Model of]

[:__primitive_generator_concept__]

[variablelist Notation
    [[`num`]            [Numeric literal, any real number value, or
                         a __karma_lazy_argument__ that evaluates to a real
                         number value of type `Num`]]
    [[`Num`]            [Type of `num`: any real number type]]]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is
not defined in __primitive_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`lit(num)`]       [Generate the real number literal `num` using the 
                         default formatting (no trailing zeros, `fixed` 
                         representation for numbers `fabs(n) <= 1e5 && fabs(n) > 1e-3`,
                         scientific representation otherwise, 3 fractional digits,
                         sign is only printed for negative literals). This 
                         generator never fails (except if the underlying output 
                         stream reports an error).]]
    [
[``float_
double_
long_double``]          [Generate the real number provided by a 
                         mandatory attribute using the default formatting (no 
                         trailing zeros, `fixed` representation for numbers 
                         `fabs(n) <= 1e5 && fabs(n) > 1e-3`, scientific 
                         representation otherwise, 3 fractional digits,
                         sign is only printed for negative literals). This 
                         generator never fails (except if the underlying output 
                         stream reports an error).]]
    [
[``float_(num)
double_(num)
long_double(num)``]     [Generate the real point number provided by the 
                         immediate literal value the generator is initialized 
                         from using the default formatting (no trailing zeros, 
                         `fixed` representation for numbers 
                         `fabs(n) <= 1e5 && fabs(n) > 1e-3`, scientific 
                         representation otherwise, 3 fractional digits, sign is 
                         only printed for negative literals). If this generator 
                         has an associated attribute it succeeds only as long as 
                         the attribute is equal to the immediate literal (except 
                         if the underlying output stream reports an error). 
                         Otherwise this generator fails and does not generate 
                         any output.]]
]

All generators listed in the table above (except `lit(num)`) are predefined 
specializations of the `real_generator<Num, Policies>` basic real
number generator type described below. It is possible to directly use this
type to create real number generators using a wide range of formatting
options.

[table
    [[Expression]       [Semantics]]
    [
[``real_generator<
    Num, Policies
>()``]
                        [Generate the real number of type `Num` 
                         provided by a mandatory attribute using the specified 
                         `Policies`. This generator never fails 
                         (except if the underlying output stream reports an 
                         error).]]
]

[heading Template parameters]

[table
    [[Parameter]        [Description]               [Default]]
    [[`Num`]            [The type of the real number to generate]  [`double`]]
    [[`Policies`]       [The policies to use while 
                         converting the real number] [`real_policies<Num>`]]
]

For more information about the type `Policies` see 
[link spirit.karma.reference.numeric.real_number.real_number_formatting_policies below]).

[heading Additional Requirements]

The following list enumerate the requirements which must be met in order to 
use a certain type `Num` to instantiate a `real_generator<Num, Policies>`.

In order to be usable as the first template parameter for `real_generator<>` 
the type `Num` must have defined:

* comparison operators for: `<`, `<=`, `==`, `!=`, `>`, and `>=` 
* numeric operators for: `+`, `-`, `/`, `*`, and `%`
* functions implementing the interface and the semantics of: `std::fmod`, 
  `std::pow`, `std::log10`, `std::lround`, `std::ltrunc`, `std::modf`, 
  `std::floor`, and `std::ceil`. These need to be defined in a way so that they 
  will be found using argument dependent lookup (ADL).
* a valid specialization of the type `std::numeric_limits<Num>` allowing for 
  numeric property inspection.


[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[`lit(num)`]       [__unused__]]

    [[`float_`]         [`float`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`float_(num)`]    [`float_`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [[`double_`]        [`double`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [[`double_(num)`]   [`double`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]

    [[`long_double`]    [`long double`, attribute is mandatory (otherwise 
                         compilation will fail)]]
    [[`long_double(num)`][`long double`, attribute is optional, if it is supplied, 
                         the generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]
    [
[``real_generator<
    Num, Policies
>()``]                  [`Num`, attribute is mandatory (otherwise compilation 
                         will fail)]]
    [
[``real_generator<
    Num, Policies
>()(num)``]             [`Num`, attribute is optional, if it is supplied, the 
                         generator compares the attribute with `num` and 
                         succeeds only if both are equal, failing otherwise.]]
]


[heading Real Number Formatting Policies]

If special formatting of a real number is needed, overload 
the policy class `real_policies<Num>` and use it as a template
parameter to the `real_generator<>` real number generator. For instance:

    // define a new real number formatting policy
    template <typename Num>
    struct scientific_policy : real_policies<Num>
    {
        // we want the numbers always to be in scientific format
        static int floatfield(Num n) { return fmtflags::scientific; }
    };

    // define a new generator type based on the new policy
    typedef real_generator<double, scientific_policy<double> > science_type;
    science_type const scientific = science_type();

    // use the new generator 
    generate(sink, science_type(), 1.0);  // will output: 1.0e00
    generate(sink, scientific, 0.1);      // will output: 1.0e-01

The template parameter `Num` should be the type to be formatted using the 
overloaded policy type. At the same time `Num` will be used as the attribute 
type of the created real number generator.


[heading Real Number Formatting Policy Expression Semantics]

A real number formatting policy should expose the following variables and 
functions:

[table
[[Expression][Description]]
[   [``
        template <typename Inserter
          , typename OutputIterator
          , typename Policies>
        bool call (OutputIterator& sink, Num n
          , Policies const& p);
    ``]
    [This is the main function used to generate the output for a real
     number. It is called by the real generator in order to perform the 
     conversion. In theory all of the work can be implemented here, but it is 
     the easiest to use existing functionality provided by the type specified
     by the template parameter `Inserter`. The default implementation of this
     functions is:
     ``
          template <typename Inserter, typename OutputIterator
            , typename Policies>
          static bool
          call (OutputIterator& sink, Num n, Policies const& p)
          {
              return Inserter::call_n(sink, n, p);
          }
     ``
      `sink`: is the output iterator to use for generation 

      `n`: is the real number to convert 

      `p`: the instance of the policy type used to instantiate this real 
           number generator.
    ]]
[   [``
        bool force_sign(Num n);
    ``]
    [The default behavior is to not to require generating a sign. If the function
     `force_sign()` returns true, then all generated numbers will have a 
     sign (`'+'` or `'-'`, zeros will have a space instead of a sign).

     `n` is the real number to output. This can be used to 
     adjust the required behavior depending on the value of this number.]]
[   [``
        bool trailing_zeros(Num n);
    ``]
    [Return whether trailing zero digits have to be emitted in the fractional 
     part of the output. If set, this flag instructs the real number
     generator to emit trailing zeros up to the required precision digits (as 
     returned by the `precision()` function).

     `n` is the real number to output. This can be used to 
     adjust the required behavior depending on the value of this number.]]
[   [``
        int floatfield(Num n);
    ``]
    [Decide, which representation type to use in the generated output.

     By default all numbers having an absolute value of zero or in between 
     `0.001` and `100000` will be generated using the fixed format, all others 
     will be generated using the scientific representation.

    The `trailing_zeros()` can be used to force the output of trailing zeros 
    in the fractional part up to the number of digits returned by the 
    `precision()` member function. The default is not to generate the trailing 
    zeros.

    `n`: is the real number to output. This can be used to 
          adjust the formatting flags depending on the value of 
          this number.

    The return value has to be either `fmtflags::scientific` (generate real
    number values in scientific notation) or `fmtflags::fixed` (generate 
    real number values in fixed-point notation).
    ]]
[   [``
        unsigned precision(Num n);
    ``]
    [Return the maximum number of decimal digits to generate in the 
     fractional part of the output.

    `n`: is the real number to output. This can be used to 
    adjust the required precision depending on the value of this number. If 
    the trailing zeros flag is specified the fractional part of the output will 
    be 'filled' with zeros, if appropriate.

    *Note:* If the trailing_zeros flag is not in effect additional semantics 
          apply. See the description for the `fraction_part()` function below. 
          Moreover, this precision will be limited to the value of 
          `std::numeric_limits<T>::digits10 + 1`.]]
[   [``
        template <bool ForceSign, 
            typename OutputIterator>
        bool integer_part(OutputIterator& sink
          , Num n, bool sign, bool force_sign);
    ``]
    [This function is called to generate the integer part of the real
      number. 

      `sink`: is the output iterator to use for generation 

      `n`: is the absolute value of the integer part of the real
           number to convert (always non-negative)

      `sign`: is the sign of the overall real number to convert.

      `force_sign`: is a flag whether a sign has to be generated even for non-
                    negative numbers (this is the same as has been returned from
                    the function `force_sign()` described above)

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
[   [``
        template <typename OutputIterator>
        bool dot(OutputIterator& sink, Num n,
          unsigned precision);
    ``]
    [This function is called to generate the decimal point.

     `sink`: is the output iterator to use for generation 

     `n`: The fractional part of the real number to convert. Note 
      that this number is scaled such, that it represents the number of units 
      which correspond to the value returned from the `precision()` function 
      earlier. I.e. a fractional part of `0.01234` is represented as `1234` 
      when the function `precision()` returned `5`.

      `precision`: The number of digits to emit as returned by the function 
                   `precision()` described above

      This is given to allow to decide, whether a decimal point has to be 
      generated at all.

      *Note:* If the `trailing_zeros` flag is not in effect additional comments 
      apply. See the description for the `fraction_part()` function below.

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
[   [``
        template <typename OutputIterator>
        bool fraction_part(OutputIterator& sink, Num n
          , unsigned adjprec, unsigned precision);
    ``]
    [This function is called to generate the fractional part of the number.

      `sink`: is the output iterator to use for generation 

      `n`: The fractional part of the real number to convert. Note 
      that this number is scaled such, that it represents the number of units 
      which correspond to the value returned from the `precision()` function 
      earlier. I.e. a fractional part of `0.01234` is represented as `1234` 
      when the function `precision()` returned `5`.

      `adjprec`: The corrected number of digits to emit (see note below)

      `precision`: The number of digits to emit as returned by the function 
                   `precision()` described above

      *Note:* If `trailing_zeros()` returns `false` the `adjprec` 
      parameter will have been corrected from the value the `precision()` 
      function returned earlier (defining the maximal number of fractional 
      digits) in the sense, that it takes into account trailing zeros. I.e. a 
      real number `0.0123` and a value of `5` returned from 
      `precision()` will result in:

      `trailing_zeros()` returned `false`: `n` will be `123`, and `adjprec` 
      will be `4` (as we need to print `0123`)

      `trailing_zeros()` returned `true`: `n` will be `1230`, and `adjprec`
      will be `5` (as we need to print `01230`)

      The missing preceding zeros in the fractional part have to be supplied 
      by the implementation of this policy function.

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
[   [``
        template <typename CharEncoding, 
            typename Tag, typename OutputIterator>
        bool exponent(
            OutputIterator& sink, long n);
    ``]
    [This function is called to generate the exponential part of the number 
     (this is called only if the `floatfield()` function returned the 
     `fmtflags::scientific` flag).

     `sink`: is the output iterator to use for generation 

     `n`: The (signed) exponential part of the real number to convert. 

     The template parameters `CharEncoding` and `Tag` are either of the type 
     `unused_type` or describe the character class and conversion to be 
     applied to any output possibly influenced by either the `lower[]` or 
     `upper[]` directives.

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
[   [``
        template <typename CharEncoding
          , typename Tag, typename OutputIterator>
        bool nan (OutputIterator& sink, Num n
          , bool force_sign);
    ``]
    [This function is called whenever the number to print is a non-normal 
     real number of type `NaN`.

     `sink`: is the output iterator to use for generation 

     `n`: is the (signed) real number to convert

    `force_sign`: is a flag whether a sign has to be generated even for non-
                  negative numbers (this is the same as has been returned from
                  the function `force_sign()` described above)

     The template parameters `CharEncoding` and `Tag` are either of the type 
     `unused_type` or describe the character class and conversion to be 
     applied to any output possibly influenced by either the `lower[]` or 
     `upper[]` directives.

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
[   [``
        template <typename CharEncoding
          , typename Tag, typename OutputIterator>
        bool inf (OutputIterator& sink, Num n
          , bool force_sign);
    ``]
    [This function is called whenever the number to print is a non-normal 
     real number of type `Inf`.

     `sink`: is the output iterator to use for generation 

     `n`: is the (signed) real number to convert

    `force_sign`: is a flag whether a sign has to be generated even for non-
                  negative numbers (this is the same as has been returned from
                  the function `force_sign()` described above)

     The template parameters `CharEncoding` and `Tag` are either of the type 
     `unused_type` or describe the character class and conversion to be 
      applied to any output possibly influenced by either the `lower[]` or 
      `upper[]` directives.

      The return value defines the outcome of the whole generator. If it is 
      `false`, no further output is generated, immediatly returning `false` from 
      the calling `real_generator` as well. If it is `true`, normal output 
      generation continues.]]
]

[tip  The easiest way to implement a proper real number formatting policy is 
      to derive a new type from the the type `real_policies<>` while overriding 
      the aspects of the formatting which need to be changed.]


[heading Complexity]

[:O(N), where `N` is the number of digits needed to represent the generated 
        real number.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use these common test functions:

[reference_karma_test]
[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_real]

Basic usage of an `double_` generator:

[reference_karma_real]

[endsect]

[endsect]
