[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Operator]

This module includes different generators which get instantiated if one of the
overloaded operators is used with more primitive generator constructs. It 
includes sequences (`<<`), alternatives (`|`), kleene star (unary `*`), plus 
(unary `+`), optional (unary `-`), lists (`%`), and the two predicates, the 
/and/ predicate (unary `&`) and the /not/ predicate (unary `!`).

[heading Module Header]

    // forwards to <boost/spirit/home/karma/operator.hpp>
    #include <boost/spirit/include/karma_operator.hpp>

[/////////////////////////////////////////////////////////////////////////////]
[section:sequence Sequences (`operator<<()`)]

[heading Description]

Generator sequences are used to consecutively combine different, more primitive 
generators. All generators in a sequence are invoked from left to right as long 
as they succeed. 

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/sequence.hpp>
    #include <boost/spirit/include/karma_sequence.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a << b`]         [The generators `a` and `b` are executed sequentially
                         from left to right and as long as they succeed. A 
                         failed generator stops the execution of the entire 
                         sequence and makes the sequence fail as well.]]
]

It is important to note, that sequences don't perform any buffering of the
output generated by its elements. That means that any failing sequence might
have already generated some output, which is /not/ rolled back. 

[tip    The only compound generators performing buffering are 
        __karma_alternative__ generators. This allows to force a sequence to 
        behave as if it did buffering by wrapping it into an alternative:

        ``a << b << c | eps(false)``

        which will /not/ generate any output in case of a failing sequence.
        Here is why: if the first alternative (our sequence) fails the 
        alternative discards any accumulated output and tries the second 
        alternative, which will always fail; if the first alternative succeeds, 
        the __karma_eps__ generator is never executed.]

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[sequence (`<<`)]  [``a: A, b: B --> (a << b): tuple<A, B>
a: A, b: Unused --> (a << b): A
a: Unused, b: B --> (a << b): B
a: Unused, b: Unused --> (a << b): Unused

a: A, b: A --> (a << b): vector<A>
a: vector<A>, b: A --> (a << b): vector<A>
a: A, b: vector<A> --> (a << b): vector<A>
a: vector<A>, b: vector<A> --> (a << b): vector<A>``]]
]

[important The table above uses `tuple<A, B>` and `vector<A>` as placeholders 
           only. 

           The notation `tuple<A, B>` stands for /any fusion sequence of two 
           elements/, where `A` is the type of its first element and `B` is the 
           type of its second element.

           The notation of `vector<A>` stands for /any STL container/ holding
           elements of type `A`.]

The attribute composition and propagation rules as shown in the table above make 
sequences somewhat special as - if all elements have the same attribute type - 
they can operate in two modes: consuming fusion sequences and consuming STL 
containers. The selected mode depends on the type of the attribute supplied

[heading Complexity]

[:The oveall complexity of the sequence generator is defined by the sum of the 
  complexities of its elements. The complexity of the sequence itself is O(N), 
  where N is the number of elements in the sequence.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test]

Some using declarations:

[reference_karma_using_declarations_sequence]

Basic usage of a sequence:

[reference_karma_sequence]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:alternative Alternatives (`operator|()`)]

[heading Description]

Generator alternatives are used to combine different, more primitive generators
into alternatives. All generators in an alternative are invoked from left to 
right until one of them succeeds. 

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/alternative.hpp>
    #include <boost/spirit/include/karma_alternative.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a | b`]          [The generators `a` and `b` are executed sequentially
                         from left to right and until one of them succeeds. A 
                         failed generator forces the alternative to try the 
                         next one. The alternative fails as a whole only if 
                         all elements of the alternative fail.]]
]

Alternatives intercept and buffer the output of the currently executed element.
This allows to avoid partial outputs from failing elements as the buffered 
content will be forwarded to the actual output only after an element succeeded.

[heading Attributes]

[table
    [[Expression]        [Attribute]]
    [[alternative (`|`)] [``a: A, b: B --> (a | b): variant<A, B>
a: A, b: Unused --> (a | b): A
a: Unused, b: B --> (a | b): B
a: Unused, b: Unused --> (a | b): Unused
a: A, b: A --> (a | b): A``]]
]

[important The table above uses `variant<A, B>` as a placeholder only. 

           The notation `variant<A, B>` stands for any data structure 
           compatible with `boost::variant`. Most of the time you will use
           `boost::variant`, though.]

Alternatives are special in terms of attribute handling as their behavior is 
not completely compile time defined. First of all the selected alternative 
element depends on the actual type of the attribute supplied to the alternative 
generator (i.e. what is stored in the variant). The attribute type supplied at 
/runtime/ narrows the set of considered alternatives to those being compatible 
attribute wise. The remaining alternatives are tried sequentially until the 
first of them succeeds. See below for an example of this behavior.

[heading Complexity]

[:The oveall complexity of the alternative generator is defined by the sum of 
  the complexities of its elements. The complexity of the alternative itself is 
  O(N), where N is the number of elements in the alternative.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test]

Some using declarations:

[reference_karma_using_declarations_alternative]

Basic usage of an alternative. While being only the second alternative, the 
`double_` generator is chosen for output formatting because the supplied 
attribute type is not compatible (i.e. not convertible) to the attribute type 
of the `string` alternative.

[reference_karma_alternative]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:kleene Kleene Star (unary `operator*()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:plus Plus (unary `operator+()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:list Lists (`operator%()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:optional Optionals (unary `operator-()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:and_predicate And Predicate (unary `operator&()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:not_predicate Not Predicate (unary `operator!()`)]

[/endsect]

[endsect]
