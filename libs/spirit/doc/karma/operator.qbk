[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Operator]

This module includes different generators which get instantiated if one of the
overloaded operators is used with more primitive generator constructs. It 
includes sequences (`<<`), alternatives (`|`), Kleene star (unary `*`), plus 
(unary `+`), optional (unary `-`), lists (`%`), and the two predicates, the 
/and/ predicate (unary `&`) and the /not/ predicate (unary `!`).

[heading Module Header]

    // forwards to <boost/spirit/home/karma/operator.hpp>
    #include <boost/spirit/include/karma_operator.hpp>

[/////////////////////////////////////////////////////////////////////////////]
[section:sequence Sequences (`operator<<()`)]

[heading Description]

Generator sequences are used to consecutively combine different, more primitive 
generators. All generators in a sequence are invoked from left to right as long 
as they succeed. 

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/sequence.hpp>
    #include <boost/spirit/include/karma_sequence.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a << b`]         [The generators `a` and `b` are executed sequentially
                         from left to right and as long as they succeed. A 
                         failed generator stops the execution of the entire 
                         sequence and makes the sequence fail as well.]]
]

It is important to note, that sequences don't perform any buffering of the
output generated by its elements. That means that any failing sequence might
have already generated some output, which is /not/ rolled back. 

[tip    The only compound generator performing buffering is 
        __karma_alternative__ generator. This allows to force a sequence to 
        behave as if it did buffering by wrapping it into an alternative:

        ``a << b << c | eps(false)``

        which will /not/ generate any output in case of a failing sequence.
        Here is why: if the first alternative (our sequence) fails, the 
        alternative discards any accumulated output and tries the second 
        alternative, which will always fail; if the first alternative succeeds, 
        the __karma_eps__ generator is never executed.]

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[sequence (`<<`)]  [``a: A, b: B --> (a << b): tuple<A, B>
a: A, b: Unused --> (a << b): A
a: Unused, b: B --> (a << b): B
a: Unused, b: Unused --> (a << b): Unused

a: A, b: A --> (a << b): vector<A>
a: vector<A>, b: A --> (a << b): vector<A>
a: A, b: vector<A> --> (a << b): vector<A>
a: vector<A>, b: vector<A> --> (a << b): vector<A>``]]
]

[important The table above uses `tuple<A, B>` and `vector<A>` as placeholders 
           only. 

           The notation `tuple<A, B>` stands for /any fusion sequence of two 
           elements/, where `A` is the type of its first element and `B` is the 
           type of its second element.

           The notation of `vector<A>` stands for /any STL container/ holding
           elements of type `A`.]

The attribute composition and propagation rules as shown in the table above make 
sequences somewhat special as - if all elements have the same attribute type - 
they can operate in two modes: consuming fusion sequences and consuming STL 
containers. The selected mode depends on the type of the attribute supplied

[heading Complexity]

[:The oveall complexity of the sequence generator is defined by the sum of the 
  complexities of its elements. The complexity of the sequence itself is O(N), 
  where N is the number of elements in the sequence.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_sequence]

Basic usage of a sequence:

[reference_karma_sequence]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:alternative Alternatives (`operator|()`)]

[heading Description]

Generator alternatives are used to combine different, more primitive generators
into alternatives. All generators in an alternative are invoked from left to 
right until one of them succeeds. 

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/alternative.hpp>
    #include <boost/spirit/include/karma_alternative.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a | b`]          [The generators `a` and `b` are executed sequentially
                         from left to right and until one of them succeeds. A 
                         failed generator forces the alternative generator to 
                         try the next one. The alternative fails as a whole 
                         only if all elements of the alternative fail. Each
                         element of the alternative gets passed the whole 
                         attribute of the alternative.]]
]

Alternatives intercept and buffer the output of the currently executed element.
This allows to avoid partial outputs from failing elements as the buffered 
content will be forwarded to the actual output only after an element succeeded.

[heading Attributes]

[table
    [[Expression]        [Attribute]]
    [[alternative (`|`)] [``a: A, b: B --> (a | b): variant<A, B>
a: A, b: Unused --> (a | b): A
a: Unused, b: B --> (a | b): B
a: Unused, b: Unused --> (a | b): Unused
a: A, b: A --> (a | b): A``]]
]

[important The table above uses `variant<A, B>` as a placeholder only. The 
           notation `variant<A, B>` stands for the type `boost::variant<A, B>`.
]

Alternatives are special in terms of attribute handling as their behavior is 
not completely compile time defined. First of all the selected alternative 
element depends on the actual type of the attribute supplied to the alternative 
generator (i.e. what is stored in the variant). The attribute type supplied at 
/runtime/ narrows the set of considered alternatives to those being compatible 
attribute wise. The remaining alternatives are tried sequentially until the 
first of them succeeds. See below for an example of this behavior.

[heading Complexity]

[:The oveall complexity of the alternative generator is defined by the sum of 
  the complexities of its elements. The complexity of the alternative itself is 
  O(N), where N is the number of elements in the alternative.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_alternative]

Basic usage of an alternative. While being only the second alternative, the 
`double_` generator is chosen for output formatting because the supplied 
attribute type is not compatible (i.e. not convertible) to the attribute type 
of the `string` alternative.

[reference_karma_alternative1]

The same formatting rules may be used to output a string. This time we supply
the string `"example"`, resulting in the first alternative to be chosen for the 
generated output.

[reference_karma_alternative2]


[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:kleene Kleene Star (unary `operator*()`)]

[heading Description]

Kleene star generators are used to repeat the execution of an embedded generator 
zero or more times. Regardless of the success of the embedded generator, the
Kleene star generator always succeeds.

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/kleene.hpp>
    #include <boost/spirit/include/karma_kleene.hpp>

Also, see __include_structure__.

[heading Model of]

[:__unary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __unary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`*a`]             [The generator `a` is executed zero or more times 
                         depending on the availability of an attribute. The 
                         execution of `a` stops after the attribute values
                         passed to the Kleene star generator are exhausted.
                         The Kleene star always succeeds (except if the 
                         underlying output stream reports an error).]]
]

[heading Attributes]

[table
    [[Expression]           [Attribute]]
    [[kleene (unary `*`)]   [``a: A --> *a: vector<A>
a: Unused --> *a: Unused``]]
]

[important The table above uses `vector<A>` as a placeholder only. The notation 
           of `vector<A>` stands for /any STL container/ holding elements of 
           type `A`.]

The Kleene star generator will execute its embedded generator once for each 
element in the provided container attribute and as long as the embedded 
generator succeeds. On each iteration it will pass the next consecutive element 
from the container attribute to the embedded generator. Therefor the number of 
iterations will not be larger than the number of elements in the container 
passed as its attribute. An empty container will make the Kleene star to not 
generate any output at all.

It is important to note, that the Kleene star does not perform any buffering 
of the output generated by its embedded elements. That means that any failing 
element generator might have already generated some output, which is /not/ 
rolled back. 

[tip    The only compound generator performing buffering is
        __karma_alternative__ generator. This allows to force a Kleene star to 
        behave as if it did buffering by wrapping it into an alternative:

        ``*a | eps(false)``

        which will /not/ generate any output in case of a failing generator `a`.

        Here is why: if the first alternative (our Kleene star) fails, the 
        alternative discards any accumulated output and tries the second 
        alternative, which will always fail; if the first alternative succeeds, 
        the __karma_eps__ generator is never executed.

        The expression:

        ``*(a | eps(false))``

        will not generate any partial output from a generator `a` if it fails
        generating in the middle of its output. The overall expresion will 
        still generate the output as produced by all succeeded invocations of 
        the generator `a`.]

[heading Complexity]

[:The oveall complexity of the Kleene star generator is defined by the 
  complexity of its embedded generator multiplied by the number of executed 
  iterations. The complexity of the Kleene star itself is O(N), where N is the 
  number of elements in the container passed as its attribute.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_kleene]

Basic usage of a Kleene star generator:

[reference_karma_kleene]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[section:plus Plus (unary `operator+()`)]

[heading Description]

The plus generator is used to repeat the execution of an embedded generator 
one or more times. It succeeds if the embedded generator has been successfully
executed at least once.

[heading Header]

    // forwards to <boost/spirit/home/karma/operator/plus.hpp>
    #include <boost/spirit/include/karma_plus.hpp>

Also, see __include_structure__.

[heading Model of]

[:__unary_generator_concept__]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __unary_generator_concept__.

[table
    [[Expression]       [Semantics]]
    [[`+a`]             [The generator `a` is executed one or more times 
                         depending on the availability of an attribute. The 
                         execution of `a` stops after the attribute values
                         passed to the plus generator are exhausted.
                         The plus succeeds as long as its embedded generator 
                         has been successfully executed at least once (except 
                         if the underlying output stream reports an error).]]
]

[heading Attributes]

[table
    [[Expression]         [Attribute]]
    [[plus (unary `+`)]   [``a: A --> +a: vector<A>
a: Unused --> +a: Unused``]]
]

[important The table above uses `vector<A>` as a placeholder only. The notation 
           of `vector<A>` stands for /any STL container/ holding elements of 
           type `A`.]

The plus generator will execute its embedded generator once for each 
element in the provided container attribute and as long as the embedded 
generator succeeds. On each iteration it will pass the next consecutive element 
from the container attribute to the embedded generator. Therefor the number of 
iterations will not be larger than the number of elements in the container 
passed as its attribute. An empty container will make the plus generator fail.

It is important to note, that the plus does not perform any buffering 
of the output generated by its embedded elements. That means that any failing 
element generator might have already generated some output, which is /not/ 
rolled back. 

[tip    The only compound generator performing buffering is
        __karma_alternative__ generator. This allows to force a plus to 
        behave as if it did buffering by wrapping it into an alternative:

        ``+a | eps(false)``

        which will /not/ generate any output in case of a failing generator `a`.

        Here is why: if the first alternative (our plus generator) fails, the 
        alternative discards any accumulated output and tries the second 
        alternative, which will always fail; if the first alternative succeeds, 
        the __karma_eps__ generator is never executed.

        The expression:

        ``+(a | eps(false))``

        will not generate any partial output from a generator `a` if it fails
        generating in the middle of its output. The overall expresion will 
        still generate the output as produced by all succeeded invocations of 
        the generator `a`.]

[heading Complexity]

[:The oveall complexity of the plus generator is defined by the 
  complexity of its embedded generator multiplied by the number of executed 
  iterations. The complexity of the plus itself is O(N), where N is the 
  number of elements in the container passed as its attribute.]

[heading Example]

Some includes:

[reference_karma_includes]

All code snippets below use this common test function:

[reference_karma_test_attr]

Some using declarations:

[reference_karma_using_declarations_plus]

Basic usage of a plus generator:

[reference_karma_plus1]

A more sophisticated use case showing how to leverage the fact that plus is 
failing for empty containers passed as its attribute:

[reference_karma_plus2]

[endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:list Lists (`operator%()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:optional Optionals (unary `operator-()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:and_predicate And Predicate (unary `operator&()`)]

[/endsect]

[/////////////////////////////////////////////////////////////////////////////]
[/section:not_predicate Not Predicate (unary `operator!()`)]

[/endsect]

[endsect]
