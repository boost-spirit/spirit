[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section What's New]

[heading Spirit Classic]

The Spirit V1.8.x code base has been integrated with Spirit V2. It is now called
__classic__. Even if the directory structure has changed (the Spirit Classic
headers are now moved to the '''$BOOST_ROOT/boost/spirit/home/classic''' directory),
we created forwarding headers allowing to compile existing applications without
any change. These forwarding headers are deprecated, though, which will result
in corresponding warnings generated for each of the headers starting with Boost
V1.38. The forwarding headers are expected to be removed in the future.

The recommended way of using Spirit Classic now is to include header files from
the directory '''$BOOST_ROOT/boost/spirit/include'''. All files of Spirit Classic
in this directory have a 'classic_' prefixed to their name. For example the
include

    #include <boost/spirit/core/core.hpp>

now should be written as:

    #include <boost/spirit/include/classic_core.hpp>

To avoid namespace conflicts with the new Spirit V2 library we moved Spirit Classic
into the namespace `boost::spirit::classic`. All references to the former
namespace `boost::spirit` need to be adjusted as soon as the header names are
corrected as described above. As an alternative you can define the preprocessor
constant `BOOST_SPIRIT_USE_OLD_NAMESPACE`, which will force the Spirit Classic
code to be in the namespace `boost::spirit` as before. This is not recommended,
though, as it may result in naming clashes.

The change of the namespace will be automatically deactivated whenever the
deprecated include files are being used. This ensures full backwards
compatibility for existing applications.

[heading Spirit V2.1] 

[heading What's changed in __qi__ and __karma__ from V2.0 to 2.x]

* __spirit__ is now based on the newest version of __boost_proto__
* `qi::phrase_parse`, `qi::phrase_format` now post-skip by default.
* `karma::generate_delimited` and `karma::format_delimited` now don't do pre-
  delimiting by default.
* Changed parameter sequence of `qi::phrase_parse`, `qi::phrase_match`, 
  `karma::generate_delimited`, and `match_delimited`. The attribute is now 
  always the last parameter.
* Added new overloads of those functions allowing to explicitely specify the
  post-skipping and pre-delimiting behavior.
* multi attribute API functions
* removed `grammar_def<>`
* removed functions `make_parser()` and `make_generator()`
* removed `qi::none` and `karma::none`
* sequences and lists now accept a standard container as its attribute
* The string placeholder terminal now can take other strings as its parameter 
  (i.e. std::string)
* all terminals taking literals now accept a (lazy) function object as well
* All placeholders for terminals and directives (such as `int_`, `double_`, 
  `verbatim`, etc.) were previously defined in the namespace `boost::spirit` 
  only. Now these are additionally imported into the namespaces
  `spirit::qi`, `spirit::karma`, and `spirit::lex` (if they are supported by 
  the corresponding sub-library.
* The terminal placeholders `char_` and `string` are not defined in the
  namespace `boost::spirit` anymore as they have been moved to the 
  character set namespaces, allowing to do proper character set 
  handling based on the used namespace (as `spirit::ascii`, etc.)
* The `uint`, `ushort`, `ulong`, and `byte` terminal placeholders have been 
  renamed to `uint_`, `ushort_`, `ulong_`, and `byte_`.
* qi::skip[]` now re-enables outer skipper if used inside `lexeme[]`
* Added `karma::maxwidth[]` directive
* `karma::delimit[]` now re-enables outer delimiter if used inside `verbatim[]`
* karma: added and-predicate (`operator&()`) and not-predicate (`operator!()`)


[heading What's changed in __lex__ from V2.0 to 2.x]

Here is a list of changes in __lex__ since version 2.0. __lex__ 2.x is a 
complete rewrite of the original __lex__ distributed. As all parts of the 
__spirit__ library it is usable either standalone or in conjunction with the
other parts. __lex__ now uses the infrastructure provided by __spirit__ version 
2.1.

* The lex::lexer_def class has been renamed to lex::lexer, while the original
  class lex::lexer does not exist anymore. This simplifies the creation of
  lexers.
* The lex::lexer class does not have the function `def(Self& self)` anymore, 
  token definitions can be added to the lexer at any time, usually in the 
  constructor of the user defined lexer class:
``
      template <typename Lexer>
      struct example_tokens : lex::lexer<Lexer>
      {
            example_lexer()
            {
                // your token definitions here
                this->self = ...
            }
      };
``
* The new lexer class now can be directly used, their is no need anymore to 
  wrap it using the `make_lexer()` template as before. Therefor the function
  `make_lexer()` has been removed.
* The `lex::tokenize_and_parse()` and `lex::tokenize_and_phrase_parse()` functions 
  have been changed to match the parameter sequence as implemented by the 
  `qi::parse()` and `qi::phrase_parse()` functions. 
  Both take a possibly arbitrary number of attribute arguments as its last 
  parameters (well, the number of attributes is limited by the macro
  `SPIRIT_ARGUMENTS_LIMIT`, which defaults to `PHOENIX_LIMIT`).
* The `lex::lexertl_lexer`, `lex::lexertl_token_set`, and `lex::lexertl_token`
  classes has been moved to the `lex::lexertl` namespace and the names have been 
  changed to `lex::lexertl::lexer`, `lex::lexertl::token_set`, `lex::lexertl::token`
  (the same applies to the `lex::lexert_actor_lexer`, and the `static_lexertl_*`
  family of types).
* The __lex__ library has been updated to use the newest version of Ben 
  Hansons __lexertl__ lexer construction library (Boost review pending).
* The `lex::lexer<Lexer>` template constructor now takes an optional parameter
  specifying the `match_flags` to be used for table generation. Currently, there
  are the following flags available:
``
        match_flags::match_default,          // no flags
        match_flags::match_not_dot_newline,  // the regex '.' doesn't match newlines
        match_flags::match_icase             // all matching operations are case insensitive
``
  If no parameter is passed to the constructor, `match_flags::match_default` is 
  used, i.e. the `.` matches newlines and matching is case sensitive.
* Now the `char_()` and `string()` placeholders can be used for token 
  definitions as a replacement for `token_def`, although it is still
  possible to use the latter one.

[endsect]
