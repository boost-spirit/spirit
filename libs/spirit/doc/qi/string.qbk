[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section String]

This module includes parsers for strings. Currently, this module
includes the literal and string parsers and the symbol table.

[heading Module Header]

    // forwards to <boost/spirit/home/qi/string.hpp>
    #include <boost/spirit/include/qi_string.hpp>

[/------------------------------------------------------------------------------]
[section lit/string]

* `boost::spirit::lit`: generates a string parser (Same as `boost::spirit::qi::lit`)
* `NS::string`: generates a string parser for the character encoding. `NS`
   is a __char_encoding_namespace__.

[heading Description]

The lit/string parser matches a string of characters. The lit/string
parser is an implicit lexeme: the `skip` parser is not applied in
between characters of the string.

[heading Header]

    // forwards to <boost/spirit/home/qi/string/lit.hpp>
    #include <boost/spirit/include/qi_lit.hpp>

Also, see __include_structure__.

[heading Model of]

[:__primitive_parser_concept__]

[variablelist Notation
    [[`s`]      [A literal string, e.g. "Hello", or a pointer/reference to a 
                null-terminated array of characters or a `std::basic_string`.]]
    [[`fs`]     [A __lazy_argument__ that evaluates to a `std::basic_string` 
                or a pointer/reference to a null-terminated array of characters.]]
    [[`ns`]     [A __char_encoding_namespace__.]]]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is
not defined in __primitive_parser_concept__.

[table
    [[Expression]       [Semantics]]
    [[`s`]              [Generate a string parser 
                        from a string, `s`.]]
    [[`lit(s)`]         [Generate a string parser 
                        from a string, `s`.]]
    [[`ns::string(s)`]  [Generate a string parser 
                        from a string, `s`.]]
    [[`fs`]             [Generate a string parser 
                        from a string, `s`, returned by 
                        invoking `fs` at parse time. 
                        See __lazy_argument__]]
    [[`lit(fs)`]        [Generate a string parser 
                        from a string, `s`, returned by 
                        invoking `fs` at parse time. 
                        See __lazy_argument__]]
    [[`ns::string(fs)`] [Generate a string parser 
                        from a string, `s`, returned by 
                        invoking `fs` at parse time. 
                        See __lazy_argument__]]
]

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[`s`]              
                        [__unused__]]
    [[`lit(s)`]         
                        [__unused__]]
    [[`ns::string(s)`]  [`std::basic_string<T>` where `T`
                        is the underlying character type
                        of `s`]]
    [[`fs`]             [`std::basic_string<T>` where `T`
                        is the underlying character type
                        of `s`]]
    [[`lit(fs)`]        [`std::basic_string<T>` where `T`
                        is the underlying character type
                        of `s`]]
    [[`ns::string(fs)`] [`std::basic_string<T>` where `T`
                        is the underlying character type
                        of `s`]]
]


[heading Complexity]

[:O(N)]

where `N` is the number of characters in the string to be parsed.

[heading Example]

Some includes:

[reference_includes]

All code snippets below use this common test function:

[reference_test]

Some using declarations:

[reference_using_declarations_lit_string]

Basic literals:

[reference_string_literals]

From a `std::string`

[reference_string_std_string]

Lazy strings using __phoenix__

[reference_string_phoenix]

[endsect] [/ lit/strin]


[/------------------------------------------------------------------------------]
[section symbols]

[heading Description]

This class `symbols` implements a symbol table: an associative container
(or map) of key-value pairs where the keys are strings. The `symbols`
class can work efficiently with 8, 16, 32 and even 64 bit characters. 

Traditionally, symbol table management is maintained seperately outside
the grammar through semantic actions. Contrary to standard practice, the
Spirit symbol table class symbols is-a parser. An instance of which may
be used anywhere in the grammar specification. It is an example of a
dynamic parser. A dynamic parser is characterized by its ability to
modify its behavior at run time. Initially, an empty symbols object
matches nothing. At any time, symbols may be added, thus, dynamically
altering its behavior.

[heading Header]

    // forwards to <boost/spirit/home/qi/string/symbols.hpp>
    #include <boost/spirit/include/qi_symbols.hpp>

Also, see __include_structure__.

[heading Synopsis]

    template <typename Char, typename T>
    struct symbols;

[heading Template parameters]

[table
    [[Parameter]        [Description]               [Default]]
    [[`Char`]           [The character type 
                        of the symbol strings.]     [`char`]]
    [[`T`]              [The data type associated 
                        with each symbol.]          [__unused_type__]]
]

[heading Model of]

[:__primitive_parser_concept__]

[variablelist Notation
    [[`Sym`]        [A `symbols` type.]]
    [[`Char`]       [A character type.]]
    [[`T`]          [A data type.]]
    [[`sym`]        [A `symbols` object.]]
    [[`sym2`]       [Another `symbols` object.]]
    [[`sseq`]       [An __stl__ container of strings.]]
    [[`dseq`]       [An __stl__ container of data with `value_type` `T`.]]
    [[`s1`...`sN`]  [A literal string, e.g. "Hello", or a pointer/reference to a 
                    null-terminated array of characters or a `std::basic_string`.]]
    [[`d1`...`dN`]  [Objects of type `T`.]]
    [[`f`]          [A callable function or function object.]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __primitive_parser_concept__.

[table
    [[Expression]                   [Semantics]]
    [[`Sym()`]                      [Construct an empty symbols.]]
    [[`Sym(sym)`]                   [Copy construct a symbols from `sym2`.]]
    [[`Sym(sseq)`]                  [Construct symbols from `sseq`.]]
    [[`Sym(sseq)`]                  [Construct symbols from `sseq` and `dseq`.]]
    [[`sym = sym`]                  [Assign `sym2` to `sym`.]]
    [[`sym = s1, s2,... sN`]        [Assigns one or more symbols (`s1`...`sN`) to `sym`.]]
    [[`sym += s1, s2,... sN`]       [Adds one or more symbols (`s1`...`sN`) to `sym`.]]
    [[`sym.add(s1)(s2)...(sN)`]     [Adds one or more symbols (`s1`...`sN`) to `sym`.]]
    [[`sym.add(s1, d1)(s2, d2)...(sN, dN)`]     
                                    [Adds one or more symbols (`s1`...`sN`) 
                                    with associated data (`d1`...`dN`) to `sym`.]]
    [[`sym -= s1, s2,... sN`]       [Remove one or more symbols (`s1`...`sN`) from `sym`.]]
    [[`sym.remove(s1)(s2)...(sN)`]  [Remove one or more symbols (`s1`...`sN`) from `sym`.]]
    [[`sym.clear()`]                [Erase all of the symbols in `sym`.]]
    [[`sym.at(s)`]                  [Returns a reference to the object associated 
                                    with symbol, `s`. If `sym` does not already 
                                    contain such an object, `at` inserts the default 
                                    object `T()`.]]
    [[`sym.find(s)`]                [Returns a pointer to the object associated 
                                    with symbol, `s`. If `sym` does not already 
                                    contain such an object, `find` returns a null 
                                    pointer.]]
    [[`sym.for_each(f)`]            [For each symbol in `sym`, `s`, a 
                                    `std::basic_string<Char>` with associated data,
                                    `d`, an object of type `T`, invoke `f(s, d)`.]]
]

[heading Attributes]

The attribute of `symbol<Char, T>` is `T`.

[heading Example]

Some includes:

[reference_includes]

Our test function:

[reference_test_attr]

Some using declarations:

[reference_using_declarations_symbols]

Symbols with data:

[reference_symbols_with_data]

When symbols is used for case-insensitive parsing (in a
__qi_no_case__ directive), added symbol strings should be in lowercase. 
Symbol strings containing one or more uppercase characters will not match any 
input when symbols is used in a `no_case` directive.

[reference_symbols_with_no_case]

[endsect] [/ symbols]

[endsect] [/ String]
