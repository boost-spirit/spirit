[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]
[section Operator]

Operators are used as a means for object composition and embedding.
Simple parsers may be composed to form composites through operator
overloading, crafted to approximate the syntax of an Extended
Backus-Normal Form (EBNF) variant. An expression such as:

    a | b

actually yields a new parser type which is a composite of its operands,
`a` and `b`. 

This module includes different parsers which get instantiated if one of
the overloaded operators is used with more primitive parser constructs.
It includes Alternative (`|`), And predicate (unary `&`), Difference
(`-`), Expect (`>`), Kleene star (unary `*`), Lists (unary `%`), Not
predicate (unary `!`), Optional (`-`), Permutation (`^`), Plus (unary
`+`), Sequence (`>>`) and Sequential-Or (`||`).

[heading Module Header]

    // forwards to <boost/spirit/home/karma/operator.hpp>
    #include <boost/spirit/include/karma_operator.hpp>

Also, see __include_structure__.

[/------------------------------------------------------------------------------]
[section:alternative Alternative (`operator|()`)]

[heading Description]

The alternative operator, `|`, matches one of two or more operands 
(`a`, `b`, ... etc.):

    a | b | ...

Alternative operands are tried one by one on a first-match-wins basis
starting from the leftmost operand. After a successfully matched
alternative is found, the parser concludes its search, essentially
short-circuiting the search for other potentially viable candidates.
This short-circuiting implicitly gives the highest priority to the
leftmost alternative.

Short-circuiting is done in the same manner as C or C++'s logical
expressions; e.g. `if (x < 3 || y < 2)` where, if `x < 3`, the `y < 2`
test is not done at all. In addition to providing an implicit priority
rule for alternatives which is necessary, given its non-deterministic
nature, short-circuiting improves the execution time. If the order of
your alternatives is logically irrelevant, strive to put the (expected)
most common choice first for maximum efficiency.

[heading Header]

    // forwards to <boost/spirit/home/qi/operator/alternative.hpp>
    #include <boost/spirit/include/qi_alternative.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_parser_concept__]

[variablelist Notation
    [[`a`, `b`]     [A __parser_concept__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_parser_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a | b`]          [Match `a` or `b`.]]
]

[heading Attributes]

See __qi_comp_attr_notation__.

[table
    [[Expression]       [Attribute]]
    [[`a | b`]  
[``a: A, b: B --> (a | b): variant<A, B>
a: A, b: Unused --> (a | b): A
a: Unused, b: B --> (a | b): B
a: Unused, b: Unused --> (a | b): Unused
a: A, b: A --> (a | b): A``]]
]

[heading Complexity]

[:The overall complexity of the alternative parser is defined by the sum
of the complexities of its elements. The complexity of the alternative
parser itself is O(N), where N is the number of alternatives.]

[heading Example]

Some using declarations:

[reference_using_declarations_alternative]

[reference_alternative]

[endsect] [/ Alternative]

[/------------------------------------------------------------------------------]
[section:sequence Sequence (`operator>>()`)]

[heading Description]

The most basic is the sequence operator, `>>`, which basically just
parses two or more operands (`a`, `b`, ... etc.), in sequence:

    a >> b >> ...

[heading Header]

    // forwards to <boost/spirit/home/qi/operator/sequence.hpp>
    #include <boost/spirit/include/qi_sequence.hpp>

Also, see __include_structure__.

[heading Model of]

[:__nary_parser_concept__]

[variablelist Notation
    [[`a`, `b`]     [A __parser_concept__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __nary_parser_concept__.

[table
    [[Expression]       [Semantics]]
    [[`a >> b`]         [Match `a` followed by `b`.]]
]

[heading Attributes]

See __qi_comp_attr_notation__.

[table
    [[Expression]       [Attribute]]
    [[`a >> b`]  
[``a: A, b: B --> (a >> b): tuple<A, B>
a: A, b: Unused --> (a >> b): A
a: Unused, b: B --> (a >> b): B
a: Unused, b: Unused --> (a >> b): Unused

a: A, b: A --> (a >> b): vector<A>
a: vector<A>, b: A --> (a >> b): vector<A>
a: A, b: vector<A> --> (a >> b): vector<A>
a: vector<A>, b: vector<A> --> (a >> b): vector<A>``]]
]

[heading Complexity]

[:The overall complexity of the sequence parser is defined by the sum of
the complexities of its elements. The complexity of the sequence itself
is O(N), where N is the number of elements in the sequence.]

[heading Example]

Some using declarations:

[reference_using_declarations_sequence]

[reference_sequence]

[endsect] [/ Sequence]

[endsect]
