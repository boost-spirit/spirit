[/==============================================================================
    Copyright (C) 2001-2009 Joel de Guzman
    Copyright (C) 2001-2009 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:directive Directive]

This module includes different directives usable to augment and parametrize 
other parsers. It includes the `no_case`, `lexeme`, `omit`, `raw`, and 
`skip` directives.


[heading Module Header]

    // forwards to <boost/spirit/home/qi/directive.hpp>
    #include <boost/spirit/include/qi_directive.hpp>

[/------------------------------------------------------------------------------]
[section:no_case no_case]

* `boost::spirit::no_case`: generates a parser directive forcing all embedded 
  parsers to do case in-sensitive matching.

[heading Description]

The `no_case[]` directive does not consume any input on it's own. The actual 
matching is done  by the embedded parsers. It's purpose is to force all 
matching of all embedded parsers to be case in-sensitive.

[heading Header]

    // forwards to <boost/spirit/home/qi/directive/no_case.hpp>
    #include <boost/spirit/include/qi_no_case.hpp>

Also, see __include_structure__.

[heading Model of]

[:This directive is special as it does not conform to any parser concept]

[variablelist Notation
    [[`p`]      [A arbitrary complex parser expression embedded inside the
                 `no_case[]` directive.]]
]

[heading Expression Semantics]

The `no_case[]` directive has no special parser semantics. It is a pure 
modifier directive. It indirectly influences the way all embedded parsers do 
their matching. It adds information (the `tag::no_case`) to the `Modifier` 
template parameter used while tranforming the `proto::expr` into the 
corresponding parser expression. This is achieved by the following 
specialization:

    namespace boost { namespace spirit
    {
        template <typename CharEncoding>
        struct is_modifier_directive<
                qi::domain
              , tag::char_code<tag::no_case, CharEncoding> >
          : mpl::true_ 
        {};
    }}

(for more details see the section describing the compilation process of the 
__boost_proto__ expression into the corresponding parser expressions).

[table
    [[Expression]       [Semantics]]
    [[`no_case[p]`]     [Force `p` to match its input case in-sensitive.]]
]

[heading Attributes]

[table
    [[Expression]       [Attribute]]
    [[`no_case[a]`]     [`A`, the no_case directive exposes the attribute of 
                         its embedded parser.]]
]

[heading Complexity]

[:The complexity is defined by the complexity of the embedded parser]

[heading Example]

Some includes:

[reference_includes]

All code snippets below use this common test function:

[reference_test]

Some using declaration:

[reference_using_declarations_symbols]

Simple usage of `no_case[]`:

[reference_no_case]

A more sophisticated use case of `no_case[]` in conjunction with a symbol 
table (see __qi_symbols__ for more details):

[reference_symbols_with_no_case]

[endsect]

[endsect]
